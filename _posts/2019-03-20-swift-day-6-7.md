---
layout: post
title: Swift Day 6,7
excerpt_separator:  <!--more-->
---

## My 6th and 7th Days of Learning Swift
* Today I've learned about closures
* Closures are a way of storing functions inside of variables
* Closures make it possible to hand functions over to functions as parameters or return them from functions

## What in Detail is there to know about closures?
* Closures can be assigned to variables and called later on
* Closures can return values and accept parameters, just like normal functions
* Closures can be passed into functions as parameters (and still have their own params and return values)
* There is a lot of shorthands for closures like '\($0)' for parameters
* External values that are used inside of closures will be captured so and their changes can be refered to later.

```swift
import UIKit

// Let`s Learn about closures today
// In Swift functions can be used just like other types such as strings or integers

let driving = {
    print("I am driving in my car right now")
}

driving()

// Accept parameters in a closure
// the parameters need to be placed inside the braces

let drive = { (place: String) in
    print("I am going to \(place) by car.")
}

drive("Hong Kong")

let watchTV = { (channel: String) in
    print("I'm going to watch some \(channel)")
}
watchTV("BBC News")

// return values from a closure

let cycling = { (destination: String) -> String in
    return "I am going to \(destination) by bike."
}

var tour = cycling("Grenoble")

print(tour)

// closures can be handed in as parameters in functions

let running = {
    print("I am going for a nice run.")
}

func aWholesomeDay(action: () -> Void) {
    print("I am working a lot")
    action()
    print("Reading a nice book!")
}

aWholesomeDay(action: running)

// If the last parameter to a function is a closure it can be declarated directly inside the function call instead of being declarated separately and handed in

func anotherWholesomeDay(action: () -> Void) {
    print("I am getting all of my ToDos done.")
    action()
    print("Watching a nice movie!")
}

// Here is what it looks like. Note: You don't even need parentheses after the function name

anotherWholesomeDay {
    print("Then I go swimming.")
}

// Now closures may become a little bit crazy: closures that are passed inside a function can actually accept parameters themeselves


func perfectDay(action: (String) -> Void) {
    print("Sleep long.")
    action("chai latte")
    print("Chill all day long.")
}

perfectDay { (drink: String) in
    print("Have \(drink) with your breakfast.")
}

// Closures that are parameters can also return values

func perfectEvening(action: (String) -> String) {
    print("Do workout.")
    let place = action("Toni")
    print(place)
    print("Eat pizza and watch Netflix together.")
}

perfectEvening { (friendName: String) -> String in
    return "Go to the place of \(friendName)."
}

// There is a shorthand notation of what we defined above
// We can remove the 'String' typehints
// We can also remove the return statements if there is only on line of code inside the closure
// There is also a shorthand for the parameter names used: One can write \($0) for the first and so on

// So the same as above would be:

perfectEvening {
    "Go to the place of \($0)"
}

// There can also be multiple parameters be put into a closure

func buyAlotOfStuff(action: (String, Int, String, Int) -> String) {
    print("Okay, let's buy a lot of stuff.")
    let list = action("apples", 6, "peaches", 4)
    print(list)
    print("Wow that was a lot to buy")
}

buyAlotOfStuff {
    "There is \($0) \($1) times and \($2) \($3) times on the list."
}

// Closures can also be returned from functions

func travel() -> (String) -> Void {
    return {
        print("I am going to \($0).")
    }
}

let destination = travel()
destination("Tokio")

// Capturing values
// Swift captures external values which are being used inside closures and stores their changes
// This is Pauls example. counter is declared inside of it and will be manipulated by the closure. All changes made to counter will stay available

func travelAgain() -> (String) -> Void {
    var counter = 1
    
    return {
        print("\(counter). I'm going to \($0)")
        counter += 1
    }
}

let result = travelAgain()
result("Tokyo")
result("Nagoya")
result("Kyoto")
result("Osaka")
```